// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.29.3
// source: global.proto

package protobufs

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	GlobalService_GetGlobalFrame_FullMethodName     = "/quilibrium.node.global.pb.GlobalService/GetGlobalFrame"
	GlobalService_GetAppShards_FullMethodName       = "/quilibrium.node.global.pb.GlobalService/GetAppShards"
	GlobalService_GetGlobalShards_FullMethodName    = "/quilibrium.node.global.pb.GlobalService/GetGlobalShards"
	GlobalService_GetLockedAddresses_FullMethodName = "/quilibrium.node.global.pb.GlobalService/GetLockedAddresses"
	GlobalService_GetWorkerInfo_FullMethodName      = "/quilibrium.node.global.pb.GlobalService/GetWorkerInfo"
)

// GlobalServiceClient is the client API for GlobalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalServiceClient interface {
	GetGlobalFrame(ctx context.Context, in *GetGlobalFrameRequest, opts ...grpc.CallOption) (*GlobalFrameResponse, error)
	GetAppShards(ctx context.Context, in *GetAppShardsRequest, opts ...grpc.CallOption) (*GetAppShardsResponse, error)
	GetGlobalShards(ctx context.Context, in *GetGlobalShardsRequest, opts ...grpc.CallOption) (*GetGlobalShardsResponse, error)
	GetLockedAddresses(ctx context.Context, in *GetLockedAddressesRequest, opts ...grpc.CallOption) (*GetLockedAddressesResponse, error)
	GetWorkerInfo(ctx context.Context, in *GlobalGetWorkerInfoRequest, opts ...grpc.CallOption) (*GlobalGetWorkerInfoResponse, error)
}

type globalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalServiceClient(cc grpc.ClientConnInterface) GlobalServiceClient {
	return &globalServiceClient{cc}
}

func (c *globalServiceClient) GetGlobalFrame(ctx context.Context, in *GetGlobalFrameRequest, opts ...grpc.CallOption) (*GlobalFrameResponse, error) {
	out := new(GlobalFrameResponse)
	err := c.cc.Invoke(ctx, GlobalService_GetGlobalFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalServiceClient) GetAppShards(ctx context.Context, in *GetAppShardsRequest, opts ...grpc.CallOption) (*GetAppShardsResponse, error) {
	out := new(GetAppShardsResponse)
	err := c.cc.Invoke(ctx, GlobalService_GetAppShards_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalServiceClient) GetGlobalShards(ctx context.Context, in *GetGlobalShardsRequest, opts ...grpc.CallOption) (*GetGlobalShardsResponse, error) {
	out := new(GetGlobalShardsResponse)
	err := c.cc.Invoke(ctx, GlobalService_GetGlobalShards_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalServiceClient) GetLockedAddresses(ctx context.Context, in *GetLockedAddressesRequest, opts ...grpc.CallOption) (*GetLockedAddressesResponse, error) {
	out := new(GetLockedAddressesResponse)
	err := c.cc.Invoke(ctx, GlobalService_GetLockedAddresses_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalServiceClient) GetWorkerInfo(ctx context.Context, in *GlobalGetWorkerInfoRequest, opts ...grpc.CallOption) (*GlobalGetWorkerInfoResponse, error) {
	out := new(GlobalGetWorkerInfoResponse)
	err := c.cc.Invoke(ctx, GlobalService_GetWorkerInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalServiceServer is the server API for GlobalService service.
// All implementations must embed UnimplementedGlobalServiceServer
// for forward compatibility
type GlobalServiceServer interface {
	GetGlobalFrame(context.Context, *GetGlobalFrameRequest) (*GlobalFrameResponse, error)
	GetAppShards(context.Context, *GetAppShardsRequest) (*GetAppShardsResponse, error)
	GetGlobalShards(context.Context, *GetGlobalShardsRequest) (*GetGlobalShardsResponse, error)
	GetLockedAddresses(context.Context, *GetLockedAddressesRequest) (*GetLockedAddressesResponse, error)
	GetWorkerInfo(context.Context, *GlobalGetWorkerInfoRequest) (*GlobalGetWorkerInfoResponse, error)
	mustEmbedUnimplementedGlobalServiceServer()
}

// UnimplementedGlobalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGlobalServiceServer struct {
}

func (UnimplementedGlobalServiceServer) GetGlobalFrame(context.Context, *GetGlobalFrameRequest) (*GlobalFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalFrame not implemented")
}
func (UnimplementedGlobalServiceServer) GetAppShards(context.Context, *GetAppShardsRequest) (*GetAppShardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppShards not implemented")
}
func (UnimplementedGlobalServiceServer) GetGlobalShards(context.Context, *GetGlobalShardsRequest) (*GetGlobalShardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalShards not implemented")
}
func (UnimplementedGlobalServiceServer) GetLockedAddresses(context.Context, *GetLockedAddressesRequest) (*GetLockedAddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLockedAddresses not implemented")
}
func (UnimplementedGlobalServiceServer) GetWorkerInfo(context.Context, *GlobalGetWorkerInfoRequest) (*GlobalGetWorkerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerInfo not implemented")
}
func (UnimplementedGlobalServiceServer) mustEmbedUnimplementedGlobalServiceServer() {}

// UnsafeGlobalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalServiceServer will
// result in compilation errors.
type UnsafeGlobalServiceServer interface {
	mustEmbedUnimplementedGlobalServiceServer()
}

func RegisterGlobalServiceServer(s grpc.ServiceRegistrar, srv GlobalServiceServer) {
	s.RegisterService(&GlobalService_ServiceDesc, srv)
}

func _GlobalService_GetGlobalFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalServiceServer).GetGlobalFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalService_GetGlobalFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalServiceServer).GetGlobalFrame(ctx, req.(*GetGlobalFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalService_GetAppShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalServiceServer).GetAppShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalService_GetAppShards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalServiceServer).GetAppShards(ctx, req.(*GetAppShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalService_GetGlobalShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalServiceServer).GetGlobalShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalService_GetGlobalShards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalServiceServer).GetGlobalShards(ctx, req.(*GetGlobalShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalService_GetLockedAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLockedAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalServiceServer).GetLockedAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalService_GetLockedAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalServiceServer).GetLockedAddresses(ctx, req.(*GetLockedAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalService_GetWorkerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobalGetWorkerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalServiceServer).GetWorkerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalService_GetWorkerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalServiceServer).GetWorkerInfo(ctx, req.(*GlobalGetWorkerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalService_ServiceDesc is the grpc.ServiceDesc for GlobalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quilibrium.node.global.pb.GlobalService",
	HandlerType: (*GlobalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGlobalFrame",
			Handler:    _GlobalService_GetGlobalFrame_Handler,
		},
		{
			MethodName: "GetAppShards",
			Handler:    _GlobalService_GetAppShards_Handler,
		},
		{
			MethodName: "GetGlobalShards",
			Handler:    _GlobalService_GetGlobalShards_Handler,
		},
		{
			MethodName: "GetLockedAddresses",
			Handler:    _GlobalService_GetLockedAddresses_Handler,
		},
		{
			MethodName: "GetWorkerInfo",
			Handler:    _GlobalService_GetWorkerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "global.proto",
}

const (
	AppShardService_GetAppShardFrame_FullMethodName = "/quilibrium.node.global.pb.AppShardService/GetAppShardFrame"
)

// AppShardServiceClient is the client API for AppShardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppShardServiceClient interface {
	GetAppShardFrame(ctx context.Context, in *GetAppShardFrameRequest, opts ...grpc.CallOption) (*AppShardFrameResponse, error)
}

type appShardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAppShardServiceClient(cc grpc.ClientConnInterface) AppShardServiceClient {
	return &appShardServiceClient{cc}
}

func (c *appShardServiceClient) GetAppShardFrame(ctx context.Context, in *GetAppShardFrameRequest, opts ...grpc.CallOption) (*AppShardFrameResponse, error) {
	out := new(AppShardFrameResponse)
	err := c.cc.Invoke(ctx, AppShardService_GetAppShardFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppShardServiceServer is the server API for AppShardService service.
// All implementations must embed UnimplementedAppShardServiceServer
// for forward compatibility
type AppShardServiceServer interface {
	GetAppShardFrame(context.Context, *GetAppShardFrameRequest) (*AppShardFrameResponse, error)
	mustEmbedUnimplementedAppShardServiceServer()
}

// UnimplementedAppShardServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAppShardServiceServer struct {
}

func (UnimplementedAppShardServiceServer) GetAppShardFrame(context.Context, *GetAppShardFrameRequest) (*AppShardFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppShardFrame not implemented")
}
func (UnimplementedAppShardServiceServer) mustEmbedUnimplementedAppShardServiceServer() {}

// UnsafeAppShardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppShardServiceServer will
// result in compilation errors.
type UnsafeAppShardServiceServer interface {
	mustEmbedUnimplementedAppShardServiceServer()
}

func RegisterAppShardServiceServer(s grpc.ServiceRegistrar, srv AppShardServiceServer) {
	s.RegisterService(&AppShardService_ServiceDesc, srv)
}

func _AppShardService_GetAppShardFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppShardFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppShardServiceServer).GetAppShardFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppShardService_GetAppShardFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppShardServiceServer).GetAppShardFrame(ctx, req.(*GetAppShardFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AppShardService_ServiceDesc is the grpc.ServiceDesc for AppShardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppShardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quilibrium.node.global.pb.AppShardService",
	HandlerType: (*AppShardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAppShardFrame",
			Handler:    _AppShardService_GetAppShardFrame_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "global.proto",
}

const (
	OnionService_Connect_FullMethodName = "/quilibrium.node.global.pb.OnionService/Connect"
)

// OnionServiceClient is the client API for OnionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OnionServiceClient interface {
	Connect(ctx context.Context, opts ...grpc.CallOption) (OnionService_ConnectClient, error)
}

type onionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOnionServiceClient(cc grpc.ClientConnInterface) OnionServiceClient {
	return &onionServiceClient{cc}
}

func (c *onionServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (OnionService_ConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &OnionService_ServiceDesc.Streams[0], OnionService_Connect_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &onionServiceConnectClient{stream}
	return x, nil
}

type OnionService_ConnectClient interface {
	Send(*SendMessage) error
	Recv() (*ReceiveMessage, error)
	grpc.ClientStream
}

type onionServiceConnectClient struct {
	grpc.ClientStream
}

func (x *onionServiceConnectClient) Send(m *SendMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *onionServiceConnectClient) Recv() (*ReceiveMessage, error) {
	m := new(ReceiveMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OnionServiceServer is the server API for OnionService service.
// All implementations must embed UnimplementedOnionServiceServer
// for forward compatibility
type OnionServiceServer interface {
	Connect(OnionService_ConnectServer) error
	mustEmbedUnimplementedOnionServiceServer()
}

// UnimplementedOnionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOnionServiceServer struct {
}

func (UnimplementedOnionServiceServer) Connect(OnionService_ConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedOnionServiceServer) mustEmbedUnimplementedOnionServiceServer() {}

// UnsafeOnionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OnionServiceServer will
// result in compilation errors.
type UnsafeOnionServiceServer interface {
	mustEmbedUnimplementedOnionServiceServer()
}

func RegisterOnionServiceServer(s grpc.ServiceRegistrar, srv OnionServiceServer) {
	s.RegisterService(&OnionService_ServiceDesc, srv)
}

func _OnionService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OnionServiceServer).Connect(&onionServiceConnectServer{stream})
}

type OnionService_ConnectServer interface {
	Send(*ReceiveMessage) error
	Recv() (*SendMessage, error)
	grpc.ServerStream
}

type onionServiceConnectServer struct {
	grpc.ServerStream
}

func (x *onionServiceConnectServer) Send(m *ReceiveMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *onionServiceConnectServer) Recv() (*SendMessage, error) {
	m := new(SendMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OnionService_ServiceDesc is the grpc.ServiceDesc for OnionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OnionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quilibrium.node.global.pb.OnionService",
	HandlerType: (*OnionServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _OnionService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "global.proto",
}

const (
	MixnetService_PutMessage_FullMethodName  = "/quilibrium.node.global.pb.MixnetService/PutMessage"
	MixnetService_RoundStream_FullMethodName = "/quilibrium.node.global.pb.MixnetService/RoundStream"
)

// MixnetServiceClient is the client API for MixnetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MixnetServiceClient interface {
	// PutMessage puts a message into the round for use with message settlement.
	PutMessage(ctx context.Context, in *PutMessageRequest, opts ...grpc.CallOption) (*PutMessageResponse, error)
	// RoundStream is the p2p stream channel for the mixnet peers.
	RoundStream(ctx context.Context, opts ...grpc.CallOption) (MixnetService_RoundStreamClient, error)
}

type mixnetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMixnetServiceClient(cc grpc.ClientConnInterface) MixnetServiceClient {
	return &mixnetServiceClient{cc}
}

func (c *mixnetServiceClient) PutMessage(ctx context.Context, in *PutMessageRequest, opts ...grpc.CallOption) (*PutMessageResponse, error) {
	out := new(PutMessageResponse)
	err := c.cc.Invoke(ctx, MixnetService_PutMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixnetServiceClient) RoundStream(ctx context.Context, opts ...grpc.CallOption) (MixnetService_RoundStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &MixnetService_ServiceDesc.Streams[0], MixnetService_RoundStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &mixnetServiceRoundStreamClient{stream}
	return x, nil
}

type MixnetService_RoundStreamClient interface {
	Send(*Message) error
	Recv() (*Message, error)
	grpc.ClientStream
}

type mixnetServiceRoundStreamClient struct {
	grpc.ClientStream
}

func (x *mixnetServiceRoundStreamClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mixnetServiceRoundStreamClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MixnetServiceServer is the server API for MixnetService service.
// All implementations must embed UnimplementedMixnetServiceServer
// for forward compatibility
type MixnetServiceServer interface {
	// PutMessage puts a message into the round for use with message settlement.
	PutMessage(context.Context, *PutMessageRequest) (*PutMessageResponse, error)
	// RoundStream is the p2p stream channel for the mixnet peers.
	RoundStream(MixnetService_RoundStreamServer) error
	mustEmbedUnimplementedMixnetServiceServer()
}

// UnimplementedMixnetServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMixnetServiceServer struct {
}

func (UnimplementedMixnetServiceServer) PutMessage(context.Context, *PutMessageRequest) (*PutMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutMessage not implemented")
}
func (UnimplementedMixnetServiceServer) RoundStream(MixnetService_RoundStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method RoundStream not implemented")
}
func (UnimplementedMixnetServiceServer) mustEmbedUnimplementedMixnetServiceServer() {}

// UnsafeMixnetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MixnetServiceServer will
// result in compilation errors.
type UnsafeMixnetServiceServer interface {
	mustEmbedUnimplementedMixnetServiceServer()
}

func RegisterMixnetServiceServer(s grpc.ServiceRegistrar, srv MixnetServiceServer) {
	s.RegisterService(&MixnetService_ServiceDesc, srv)
}

func _MixnetService_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixnetServiceServer).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MixnetService_PutMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixnetServiceServer).PutMessage(ctx, req.(*PutMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixnetService_RoundStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MixnetServiceServer).RoundStream(&mixnetServiceRoundStreamServer{stream})
}

type MixnetService_RoundStreamServer interface {
	Send(*Message) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type mixnetServiceRoundStreamServer struct {
	grpc.ServerStream
}

func (x *mixnetServiceRoundStreamServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mixnetServiceRoundStreamServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MixnetService_ServiceDesc is the grpc.ServiceDesc for MixnetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MixnetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quilibrium.node.global.pb.MixnetService",
	HandlerType: (*MixnetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutMessage",
			Handler:    _MixnetService_PutMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RoundStream",
			Handler:       _MixnetService_RoundStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "global.proto",
}

const (
	KeyRegistryService_GetKeyRegistry_FullMethodName         = "/quilibrium.node.global.pb.KeyRegistryService/GetKeyRegistry"
	KeyRegistryService_GetKeyRegistryByProver_FullMethodName = "/quilibrium.node.global.pb.KeyRegistryService/GetKeyRegistryByProver"
	KeyRegistryService_PutIdentityKey_FullMethodName         = "/quilibrium.node.global.pb.KeyRegistryService/PutIdentityKey"
	KeyRegistryService_PutProvingKey_FullMethodName          = "/quilibrium.node.global.pb.KeyRegistryService/PutProvingKey"
	KeyRegistryService_PutCrossSignature_FullMethodName      = "/quilibrium.node.global.pb.KeyRegistryService/PutCrossSignature"
	KeyRegistryService_PutSignedKey_FullMethodName           = "/quilibrium.node.global.pb.KeyRegistryService/PutSignedKey"
	KeyRegistryService_GetIdentityKey_FullMethodName         = "/quilibrium.node.global.pb.KeyRegistryService/GetIdentityKey"
	KeyRegistryService_GetProvingKey_FullMethodName          = "/quilibrium.node.global.pb.KeyRegistryService/GetProvingKey"
	KeyRegistryService_GetSignedKey_FullMethodName           = "/quilibrium.node.global.pb.KeyRegistryService/GetSignedKey"
	KeyRegistryService_GetSignedKeysByParent_FullMethodName  = "/quilibrium.node.global.pb.KeyRegistryService/GetSignedKeysByParent"
	KeyRegistryService_RangeProvingKeys_FullMethodName       = "/quilibrium.node.global.pb.KeyRegistryService/RangeProvingKeys"
	KeyRegistryService_RangeIdentityKeys_FullMethodName      = "/quilibrium.node.global.pb.KeyRegistryService/RangeIdentityKeys"
	KeyRegistryService_RangeSignedKeys_FullMethodName        = "/quilibrium.node.global.pb.KeyRegistryService/RangeSignedKeys"
)

// KeyRegistryServiceClient is the client API for KeyRegistryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeyRegistryServiceClient interface {
	// GetKeyRegistry retrieves the complete key registry for an identity key
	// address
	GetKeyRegistry(ctx context.Context, in *GetKeyRegistryRequest, opts ...grpc.CallOption) (*GetKeyRegistryResponse, error)
	// GetKeyRegistryByProver retrieves the complete key registry for a prover key
	// address
	GetKeyRegistryByProver(ctx context.Context, in *GetKeyRegistryByProverRequest, opts ...grpc.CallOption) (*GetKeyRegistryByProverResponse, error)
	// PutIdentityKey stores an identity key
	PutIdentityKey(ctx context.Context, in *PutIdentityKeyRequest, opts ...grpc.CallOption) (*PutIdentityKeyResponse, error)
	// PutProvingKey stores a proving key with proof of possession
	PutProvingKey(ctx context.Context, in *PutProvingKeyRequest, opts ...grpc.CallOption) (*PutProvingKeyResponse, error)
	// PutCrossSignature stores cross signatures between identity and proving keys
	PutCrossSignature(ctx context.Context, in *PutCrossSignatureRequest, opts ...grpc.CallOption) (*PutCrossSignatureResponse, error)
	// PutSignedKey stores a signed X448 key
	PutSignedKey(ctx context.Context, in *PutSignedKeyRequest, opts ...grpc.CallOption) (*PutSignedKeyResponse, error)
	// GetIdentityKey retrieves an identity key by address
	GetIdentityKey(ctx context.Context, in *GetIdentityKeyRequest, opts ...grpc.CallOption) (*GetIdentityKeyResponse, error)
	// GetProvingKey retrieves a proving key by address
	GetProvingKey(ctx context.Context, in *GetProvingKeyRequest, opts ...grpc.CallOption) (*GetProvingKeyResponse, error)
	// GetSignedKey retrieves a signed key by address
	GetSignedKey(ctx context.Context, in *GetSignedKeyRequest, opts ...grpc.CallOption) (*GetSignedKeyResponse, error)
	// GetSignedKeysByParent retrieves all signed keys for a parent key
	GetSignedKeysByParent(ctx context.Context, in *GetSignedKeysByParentRequest, opts ...grpc.CallOption) (*GetSignedKeysByParentResponse, error)
	// RangeProvingKeys returns an iterator over all proving keys
	RangeProvingKeys(ctx context.Context, in *RangeProvingKeysRequest, opts ...grpc.CallOption) (*RangeProvingKeysResponse, error)
	// RangeIdentityKeys returns an iterator over all identity keys
	RangeIdentityKeys(ctx context.Context, in *RangeIdentityKeysRequest, opts ...grpc.CallOption) (*RangeIdentityKeysResponse, error)
	// RangeSignedKeys returns an iterator over signed keys
	RangeSignedKeys(ctx context.Context, in *RangeSignedKeysRequest, opts ...grpc.CallOption) (*RangeSignedKeysResponse, error)
}

type keyRegistryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeyRegistryServiceClient(cc grpc.ClientConnInterface) KeyRegistryServiceClient {
	return &keyRegistryServiceClient{cc}
}

func (c *keyRegistryServiceClient) GetKeyRegistry(ctx context.Context, in *GetKeyRegistryRequest, opts ...grpc.CallOption) (*GetKeyRegistryResponse, error) {
	out := new(GetKeyRegistryResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_GetKeyRegistry_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) GetKeyRegistryByProver(ctx context.Context, in *GetKeyRegistryByProverRequest, opts ...grpc.CallOption) (*GetKeyRegistryByProverResponse, error) {
	out := new(GetKeyRegistryByProverResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_GetKeyRegistryByProver_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) PutIdentityKey(ctx context.Context, in *PutIdentityKeyRequest, opts ...grpc.CallOption) (*PutIdentityKeyResponse, error) {
	out := new(PutIdentityKeyResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_PutIdentityKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) PutProvingKey(ctx context.Context, in *PutProvingKeyRequest, opts ...grpc.CallOption) (*PutProvingKeyResponse, error) {
	out := new(PutProvingKeyResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_PutProvingKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) PutCrossSignature(ctx context.Context, in *PutCrossSignatureRequest, opts ...grpc.CallOption) (*PutCrossSignatureResponse, error) {
	out := new(PutCrossSignatureResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_PutCrossSignature_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) PutSignedKey(ctx context.Context, in *PutSignedKeyRequest, opts ...grpc.CallOption) (*PutSignedKeyResponse, error) {
	out := new(PutSignedKeyResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_PutSignedKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) GetIdentityKey(ctx context.Context, in *GetIdentityKeyRequest, opts ...grpc.CallOption) (*GetIdentityKeyResponse, error) {
	out := new(GetIdentityKeyResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_GetIdentityKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) GetProvingKey(ctx context.Context, in *GetProvingKeyRequest, opts ...grpc.CallOption) (*GetProvingKeyResponse, error) {
	out := new(GetProvingKeyResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_GetProvingKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) GetSignedKey(ctx context.Context, in *GetSignedKeyRequest, opts ...grpc.CallOption) (*GetSignedKeyResponse, error) {
	out := new(GetSignedKeyResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_GetSignedKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) GetSignedKeysByParent(ctx context.Context, in *GetSignedKeysByParentRequest, opts ...grpc.CallOption) (*GetSignedKeysByParentResponse, error) {
	out := new(GetSignedKeysByParentResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_GetSignedKeysByParent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) RangeProvingKeys(ctx context.Context, in *RangeProvingKeysRequest, opts ...grpc.CallOption) (*RangeProvingKeysResponse, error) {
	out := new(RangeProvingKeysResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_RangeProvingKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) RangeIdentityKeys(ctx context.Context, in *RangeIdentityKeysRequest, opts ...grpc.CallOption) (*RangeIdentityKeysResponse, error) {
	out := new(RangeIdentityKeysResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_RangeIdentityKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyRegistryServiceClient) RangeSignedKeys(ctx context.Context, in *RangeSignedKeysRequest, opts ...grpc.CallOption) (*RangeSignedKeysResponse, error) {
	out := new(RangeSignedKeysResponse)
	err := c.cc.Invoke(ctx, KeyRegistryService_RangeSignedKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeyRegistryServiceServer is the server API for KeyRegistryService service.
// All implementations must embed UnimplementedKeyRegistryServiceServer
// for forward compatibility
type KeyRegistryServiceServer interface {
	// GetKeyRegistry retrieves the complete key registry for an identity key
	// address
	GetKeyRegistry(context.Context, *GetKeyRegistryRequest) (*GetKeyRegistryResponse, error)
	// GetKeyRegistryByProver retrieves the complete key registry for a prover key
	// address
	GetKeyRegistryByProver(context.Context, *GetKeyRegistryByProverRequest) (*GetKeyRegistryByProverResponse, error)
	// PutIdentityKey stores an identity key
	PutIdentityKey(context.Context, *PutIdentityKeyRequest) (*PutIdentityKeyResponse, error)
	// PutProvingKey stores a proving key with proof of possession
	PutProvingKey(context.Context, *PutProvingKeyRequest) (*PutProvingKeyResponse, error)
	// PutCrossSignature stores cross signatures between identity and proving keys
	PutCrossSignature(context.Context, *PutCrossSignatureRequest) (*PutCrossSignatureResponse, error)
	// PutSignedKey stores a signed X448 key
	PutSignedKey(context.Context, *PutSignedKeyRequest) (*PutSignedKeyResponse, error)
	// GetIdentityKey retrieves an identity key by address
	GetIdentityKey(context.Context, *GetIdentityKeyRequest) (*GetIdentityKeyResponse, error)
	// GetProvingKey retrieves a proving key by address
	GetProvingKey(context.Context, *GetProvingKeyRequest) (*GetProvingKeyResponse, error)
	// GetSignedKey retrieves a signed key by address
	GetSignedKey(context.Context, *GetSignedKeyRequest) (*GetSignedKeyResponse, error)
	// GetSignedKeysByParent retrieves all signed keys for a parent key
	GetSignedKeysByParent(context.Context, *GetSignedKeysByParentRequest) (*GetSignedKeysByParentResponse, error)
	// RangeProvingKeys returns an iterator over all proving keys
	RangeProvingKeys(context.Context, *RangeProvingKeysRequest) (*RangeProvingKeysResponse, error)
	// RangeIdentityKeys returns an iterator over all identity keys
	RangeIdentityKeys(context.Context, *RangeIdentityKeysRequest) (*RangeIdentityKeysResponse, error)
	// RangeSignedKeys returns an iterator over signed keys
	RangeSignedKeys(context.Context, *RangeSignedKeysRequest) (*RangeSignedKeysResponse, error)
	mustEmbedUnimplementedKeyRegistryServiceServer()
}

// UnimplementedKeyRegistryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKeyRegistryServiceServer struct {
}

func (UnimplementedKeyRegistryServiceServer) GetKeyRegistry(context.Context, *GetKeyRegistryRequest) (*GetKeyRegistryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyRegistry not implemented")
}
func (UnimplementedKeyRegistryServiceServer) GetKeyRegistryByProver(context.Context, *GetKeyRegistryByProverRequest) (*GetKeyRegistryByProverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyRegistryByProver not implemented")
}
func (UnimplementedKeyRegistryServiceServer) PutIdentityKey(context.Context, *PutIdentityKeyRequest) (*PutIdentityKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutIdentityKey not implemented")
}
func (UnimplementedKeyRegistryServiceServer) PutProvingKey(context.Context, *PutProvingKeyRequest) (*PutProvingKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutProvingKey not implemented")
}
func (UnimplementedKeyRegistryServiceServer) PutCrossSignature(context.Context, *PutCrossSignatureRequest) (*PutCrossSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutCrossSignature not implemented")
}
func (UnimplementedKeyRegistryServiceServer) PutSignedKey(context.Context, *PutSignedKeyRequest) (*PutSignedKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSignedKey not implemented")
}
func (UnimplementedKeyRegistryServiceServer) GetIdentityKey(context.Context, *GetIdentityKeyRequest) (*GetIdentityKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIdentityKey not implemented")
}
func (UnimplementedKeyRegistryServiceServer) GetProvingKey(context.Context, *GetProvingKeyRequest) (*GetProvingKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProvingKey not implemented")
}
func (UnimplementedKeyRegistryServiceServer) GetSignedKey(context.Context, *GetSignedKeyRequest) (*GetSignedKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSignedKey not implemented")
}
func (UnimplementedKeyRegistryServiceServer) GetSignedKeysByParent(context.Context, *GetSignedKeysByParentRequest) (*GetSignedKeysByParentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSignedKeysByParent not implemented")
}
func (UnimplementedKeyRegistryServiceServer) RangeProvingKeys(context.Context, *RangeProvingKeysRequest) (*RangeProvingKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeProvingKeys not implemented")
}
func (UnimplementedKeyRegistryServiceServer) RangeIdentityKeys(context.Context, *RangeIdentityKeysRequest) (*RangeIdentityKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeIdentityKeys not implemented")
}
func (UnimplementedKeyRegistryServiceServer) RangeSignedKeys(context.Context, *RangeSignedKeysRequest) (*RangeSignedKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeSignedKeys not implemented")
}
func (UnimplementedKeyRegistryServiceServer) mustEmbedUnimplementedKeyRegistryServiceServer() {}

// UnsafeKeyRegistryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeyRegistryServiceServer will
// result in compilation errors.
type UnsafeKeyRegistryServiceServer interface {
	mustEmbedUnimplementedKeyRegistryServiceServer()
}

func RegisterKeyRegistryServiceServer(s grpc.ServiceRegistrar, srv KeyRegistryServiceServer) {
	s.RegisterService(&KeyRegistryService_ServiceDesc, srv)
}

func _KeyRegistryService_GetKeyRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).GetKeyRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_GetKeyRegistry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).GetKeyRegistry(ctx, req.(*GetKeyRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_GetKeyRegistryByProver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRegistryByProverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).GetKeyRegistryByProver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_GetKeyRegistryByProver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).GetKeyRegistryByProver(ctx, req.(*GetKeyRegistryByProverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_PutIdentityKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutIdentityKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).PutIdentityKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_PutIdentityKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).PutIdentityKey(ctx, req.(*PutIdentityKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_PutProvingKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutProvingKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).PutProvingKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_PutProvingKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).PutProvingKey(ctx, req.(*PutProvingKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_PutCrossSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutCrossSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).PutCrossSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_PutCrossSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).PutCrossSignature(ctx, req.(*PutCrossSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_PutSignedKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutSignedKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).PutSignedKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_PutSignedKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).PutSignedKey(ctx, req.(*PutSignedKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_GetIdentityKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentityKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).GetIdentityKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_GetIdentityKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).GetIdentityKey(ctx, req.(*GetIdentityKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_GetProvingKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProvingKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).GetProvingKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_GetProvingKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).GetProvingKey(ctx, req.(*GetProvingKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_GetSignedKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSignedKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).GetSignedKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_GetSignedKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).GetSignedKey(ctx, req.(*GetSignedKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_GetSignedKeysByParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSignedKeysByParentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).GetSignedKeysByParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_GetSignedKeysByParent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).GetSignedKeysByParent(ctx, req.(*GetSignedKeysByParentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_RangeProvingKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeProvingKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).RangeProvingKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_RangeProvingKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).RangeProvingKeys(ctx, req.(*RangeProvingKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_RangeIdentityKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeIdentityKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).RangeIdentityKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_RangeIdentityKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).RangeIdentityKeys(ctx, req.(*RangeIdentityKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyRegistryService_RangeSignedKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeSignedKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyRegistryServiceServer).RangeSignedKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyRegistryService_RangeSignedKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyRegistryServiceServer).RangeSignedKeys(ctx, req.(*RangeSignedKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeyRegistryService_ServiceDesc is the grpc.ServiceDesc for KeyRegistryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeyRegistryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quilibrium.node.global.pb.KeyRegistryService",
	HandlerType: (*KeyRegistryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKeyRegistry",
			Handler:    _KeyRegistryService_GetKeyRegistry_Handler,
		},
		{
			MethodName: "GetKeyRegistryByProver",
			Handler:    _KeyRegistryService_GetKeyRegistryByProver_Handler,
		},
		{
			MethodName: "PutIdentityKey",
			Handler:    _KeyRegistryService_PutIdentityKey_Handler,
		},
		{
			MethodName: "PutProvingKey",
			Handler:    _KeyRegistryService_PutProvingKey_Handler,
		},
		{
			MethodName: "PutCrossSignature",
			Handler:    _KeyRegistryService_PutCrossSignature_Handler,
		},
		{
			MethodName: "PutSignedKey",
			Handler:    _KeyRegistryService_PutSignedKey_Handler,
		},
		{
			MethodName: "GetIdentityKey",
			Handler:    _KeyRegistryService_GetIdentityKey_Handler,
		},
		{
			MethodName: "GetProvingKey",
			Handler:    _KeyRegistryService_GetProvingKey_Handler,
		},
		{
			MethodName: "GetSignedKey",
			Handler:    _KeyRegistryService_GetSignedKey_Handler,
		},
		{
			MethodName: "GetSignedKeysByParent",
			Handler:    _KeyRegistryService_GetSignedKeysByParent_Handler,
		},
		{
			MethodName: "RangeProvingKeys",
			Handler:    _KeyRegistryService_RangeProvingKeys_Handler,
		},
		{
			MethodName: "RangeIdentityKeys",
			Handler:    _KeyRegistryService_RangeIdentityKeys_Handler,
		},
		{
			MethodName: "RangeSignedKeys",
			Handler:    _KeyRegistryService_RangeSignedKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "global.proto",
}

const (
	DispatchService_PutInboxMessage_FullMethodName  = "/quilibrium.node.global.pb.DispatchService/PutInboxMessage"
	DispatchService_GetInboxMessages_FullMethodName = "/quilibrium.node.global.pb.DispatchService/GetInboxMessages"
	DispatchService_PutHub_FullMethodName           = "/quilibrium.node.global.pb.DispatchService/PutHub"
	DispatchService_GetHub_FullMethodName           = "/quilibrium.node.global.pb.DispatchService/GetHub"
	DispatchService_Sync_FullMethodName             = "/quilibrium.node.global.pb.DispatchService/Sync"
)

// DispatchServiceClient is the client API for DispatchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DispatchServiceClient interface {
	// Store a new message in an inbox
	PutInboxMessage(ctx context.Context, in *InboxMessagePut, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Retrieve messages based on criteria
	GetInboxMessages(ctx context.Context, in *InboxMessageRequest, opts ...grpc.CallOption) (*InboxMessageResponse, error)
	// Create or update a hub
	PutHub(ctx context.Context, in *HubPut, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Retrieve hub information
	GetHub(ctx context.Context, in *HubRequest, opts ...grpc.CallOption) (*HubResponse, error)
	// Synchronize dispatch data
	Sync(ctx context.Context, in *DispatchSyncRequest, opts ...grpc.CallOption) (*DispatchSyncResponse, error)
}

type dispatchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDispatchServiceClient(cc grpc.ClientConnInterface) DispatchServiceClient {
	return &dispatchServiceClient{cc}
}

func (c *dispatchServiceClient) PutInboxMessage(ctx context.Context, in *InboxMessagePut, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DispatchService_PutInboxMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatchServiceClient) GetInboxMessages(ctx context.Context, in *InboxMessageRequest, opts ...grpc.CallOption) (*InboxMessageResponse, error) {
	out := new(InboxMessageResponse)
	err := c.cc.Invoke(ctx, DispatchService_GetInboxMessages_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatchServiceClient) PutHub(ctx context.Context, in *HubPut, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DispatchService_PutHub_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatchServiceClient) GetHub(ctx context.Context, in *HubRequest, opts ...grpc.CallOption) (*HubResponse, error) {
	out := new(HubResponse)
	err := c.cc.Invoke(ctx, DispatchService_GetHub_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatchServiceClient) Sync(ctx context.Context, in *DispatchSyncRequest, opts ...grpc.CallOption) (*DispatchSyncResponse, error) {
	out := new(DispatchSyncResponse)
	err := c.cc.Invoke(ctx, DispatchService_Sync_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DispatchServiceServer is the server API for DispatchService service.
// All implementations must embed UnimplementedDispatchServiceServer
// for forward compatibility
type DispatchServiceServer interface {
	// Store a new message in an inbox
	PutInboxMessage(context.Context, *InboxMessagePut) (*emptypb.Empty, error)
	// Retrieve messages based on criteria
	GetInboxMessages(context.Context, *InboxMessageRequest) (*InboxMessageResponse, error)
	// Create or update a hub
	PutHub(context.Context, *HubPut) (*emptypb.Empty, error)
	// Retrieve hub information
	GetHub(context.Context, *HubRequest) (*HubResponse, error)
	// Synchronize dispatch data
	Sync(context.Context, *DispatchSyncRequest) (*DispatchSyncResponse, error)
	mustEmbedUnimplementedDispatchServiceServer()
}

// UnimplementedDispatchServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDispatchServiceServer struct {
}

func (UnimplementedDispatchServiceServer) PutInboxMessage(context.Context, *InboxMessagePut) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutInboxMessage not implemented")
}
func (UnimplementedDispatchServiceServer) GetInboxMessages(context.Context, *InboxMessageRequest) (*InboxMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInboxMessages not implemented")
}
func (UnimplementedDispatchServiceServer) PutHub(context.Context, *HubPut) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutHub not implemented")
}
func (UnimplementedDispatchServiceServer) GetHub(context.Context, *HubRequest) (*HubResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHub not implemented")
}
func (UnimplementedDispatchServiceServer) Sync(context.Context, *DispatchSyncRequest) (*DispatchSyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (UnimplementedDispatchServiceServer) mustEmbedUnimplementedDispatchServiceServer() {}

// UnsafeDispatchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DispatchServiceServer will
// result in compilation errors.
type UnsafeDispatchServiceServer interface {
	mustEmbedUnimplementedDispatchServiceServer()
}

func RegisterDispatchServiceServer(s grpc.ServiceRegistrar, srv DispatchServiceServer) {
	s.RegisterService(&DispatchService_ServiceDesc, srv)
}

func _DispatchService_PutInboxMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InboxMessagePut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).PutInboxMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_PutInboxMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).PutInboxMessage(ctx, req.(*InboxMessagePut))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatchService_GetInboxMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InboxMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).GetInboxMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_GetInboxMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).GetInboxMessages(ctx, req.(*InboxMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatchService_PutHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HubPut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).PutHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_PutHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).PutHub(ctx, req.(*HubPut))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatchService_GetHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).GetHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_GetHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).GetHub(ctx, req.(*HubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatchService_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatchSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_Sync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).Sync(ctx, req.(*DispatchSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DispatchService_ServiceDesc is the grpc.ServiceDesc for DispatchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DispatchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quilibrium.node.global.pb.DispatchService",
	HandlerType: (*DispatchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutInboxMessage",
			Handler:    _DispatchService_PutInboxMessage_Handler,
		},
		{
			MethodName: "GetInboxMessages",
			Handler:    _DispatchService_GetInboxMessages_Handler,
		},
		{
			MethodName: "PutHub",
			Handler:    _DispatchService_PutHub_Handler,
		},
		{
			MethodName: "GetHub",
			Handler:    _DispatchService_GetHub_Handler,
		},
		{
			MethodName: "Sync",
			Handler:    _DispatchService_Sync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "global.proto",
}
