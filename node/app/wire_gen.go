// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"github.com/google/wire"
	"go.uber.org/zap"
	"source.quilibrium.com/quilibrium/monorepo/bls48581"
	"source.quilibrium.com/quilibrium/monorepo/bulletproofs"
	"source.quilibrium.com/quilibrium/monorepo/channel"
	"source.quilibrium.com/quilibrium/monorepo/config"
	"source.quilibrium.com/quilibrium/monorepo/node/compiler"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/app"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/difficulty"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/fees"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/global"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/provers"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/registration"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/reward"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/time"
	"source.quilibrium.com/quilibrium/monorepo/node/consensus/validator"
	"source.quilibrium.com/quilibrium/monorepo/node/datarpc"
	"source.quilibrium.com/quilibrium/monorepo/node/keys"
	"source.quilibrium.com/quilibrium/monorepo/node/p2p"
	"source.quilibrium.com/quilibrium/monorepo/node/rpc"
	store2 "source.quilibrium.com/quilibrium/monorepo/node/store"
	"source.quilibrium.com/quilibrium/monorepo/node/tests"
	channel2 "source.quilibrium.com/quilibrium/monorepo/types/channel"
	compiler2 "source.quilibrium.com/quilibrium/monorepo/types/compiler"
	"source.quilibrium.com/quilibrium/monorepo/types/consensus"
	"source.quilibrium.com/quilibrium/monorepo/types/crypto"
	"source.quilibrium.com/quilibrium/monorepo/types/hypergraph"
	keys2 "source.quilibrium.com/quilibrium/monorepo/types/keys"
	p2p2 "source.quilibrium.com/quilibrium/monorepo/types/p2p"
	"source.quilibrium.com/quilibrium/monorepo/types/store"
	"source.quilibrium.com/quilibrium/monorepo/types/tries"
	"source.quilibrium.com/quilibrium/monorepo/vdf"
	"source.quilibrium.com/quilibrium/monorepo/verenc"
)

// Injectors from wire.go:

func NewDHTNode(logger *zap.Logger, configConfig *config.Config, uint2 uint) (*DHTNode, error) {
	p2PConfig := configConfig.P2P
	engineConfig := configConfig.Engine
	blossomSub := p2p.NewBlossomSub(p2PConfig, engineConfig, logger, uint2)
	dhtNode, err := newDHTNode(blossomSub)
	if err != nil {
		return nil, err
	}
	return dhtNode, nil
}

func NewDBConsole(configConfig *config.Config) (*DBConsole, error) {
	dbConsole, err := newDBConsole(configConfig)
	if err != nil {
		return nil, err
	}
	return dbConsole, nil
}

func NewClockStore(logger *zap.Logger, configConfig *config.Config, uint2 uint) (store.ClockStore, error) {
	dbConfig := configConfig.DB
	pebbleDB := store2.NewPebbleDB(logger, dbConfig, uint2)
	pebbleClockStore := store2.NewPebbleClockStore(pebbleDB, logger)
	return pebbleClockStore, nil
}

func NewDataWorkerNodeWithProxyPubsub(logger *zap.Logger, config2 *config.Config, coreId uint, rpcMultiaddr string, parentProcess int) (*DataWorkerNode, error) {
	dbConfig := config2.DB
	pebbleDB := store2.NewPebbleDB(logger, dbConfig, coreId)
	pebbleDataProofStore := store2.NewPebbleDataProofStore(pebbleDB, logger)
	pebbleClockStore := store2.NewPebbleClockStore(pebbleDB, logger)
	pebbleTokenStore := store2.NewPebbleTokenStore(pebbleDB, logger)
	bls48581KeyConstructor := provideBLSConstructor()
	decaf448KeyConstructor := provideDecafConstructor()
	fileKeyManager := keys.NewFileKeyManager(config2, bls48581KeyConstructor, decaf448KeyConstructor, logger)
	frameProver := vdf.NewCachedWesolowskiFrameProver(logger)
	pebbleKeyStore := store2.NewPebbleKeyStore(pebbleDB, logger)
	decaf448BulletproofProver := bulletproofs.NewBulletproofProver()
	cachedSignerRegistry, err := registration.NewCachedSignerRegistry(pebbleKeyStore, fileKeyManager, bls48581KeyConstructor, decaf448BulletproofProver, logger)
	if err != nil {
		return nil, err
	}
	mpCitHVerifiableEncryptor := newVerifiableEncryptor()
	kzgInclusionProver := bls48581.NewKZGInclusionProver(logger)
	pebbleHypergraphStore := store2.NewPebbleHypergraphStore(dbConfig, pebbleDB, logger, mpCitHVerifiableEncryptor, kzgInclusionProver)
	hypergraph, err := provideHypergraph(pebbleHypergraphStore)
	if err != nil {
		return nil, err
	}
	proverRegistry, err := provers.NewProverRegistry(logger, hypergraph)
	if err != nil {
		return nil, err
	}
	p2PConfig := config2.P2P
	engineConfig := config2.Engine
	proxyBlossomSub, err := rpc.NewProxyBlossomSub(p2PConfig, engineConfig, logger, coreId)
	if err != nil {
		return nil, err
	}
	pebbleInboxStore := store2.NewPebbleInboxStore(pebbleDB, logger)
	pebbleShardsStore := store2.NewPebbleShardsStore(pebbleDB, logger)
	bedlamCompiler := compiler.NewBedlamCompiler()
	inMemoryPeerInfoManager := p2p.NewInMemoryPeerInfoManager(logger)
	dynamicFeeManager := fees.NewDynamicFeeManager(logger, kzgInclusionProver)
	blsAppFrameValidator := validator.NewBLSAppFrameValidator(proverRegistry, bls48581KeyConstructor, frameProver, logger)
	blsGlobalFrameValidator := validator.NewBLSGlobalFrameValidator(proverRegistry, bls48581KeyConstructor, frameProver, logger)
	uint64_2 := provideDifficultyAnchorFrameNumber(config2)
	int64_2 := provideDifficultyAnchorParentTime()
	uint32_2 := provideDifficultyAnchorDifficulty()
	asertDifficultyAdjuster := difficulty.NewAsertDifficultyAdjuster(uint64_2, int64_2, uint32_2)
	optimizedProofOfMeaningfulWorkRewardIssuance := reward.NewOptRewardIssuance()
	doubleRatchetEncryptedChannel := channel.NewDoubleRatchetEncryptedChannel()
	appConsensusEngineFactory := app.NewAppConsensusEngineFactory(logger, config2, proxyBlossomSub, hypergraph, fileKeyManager, pebbleKeyStore, pebbleClockStore, pebbleInboxStore, pebbleShardsStore, pebbleHypergraphStore, frameProver, kzgInclusionProver, decaf448BulletproofProver, mpCitHVerifiableEncryptor, decaf448KeyConstructor, bedlamCompiler, cachedSignerRegistry, proverRegistry, inMemoryPeerInfoManager, dynamicFeeManager, blsAppFrameValidator, blsGlobalFrameValidator, asertDifficultyAdjuster, optimizedProofOfMeaningfulWorkRewardIssuance, bls48581KeyConstructor, doubleRatchetEncryptedChannel)
	dataWorkerIPCServer := provideDataWorkerIPC(rpcMultiaddr, config2, cachedSignerRegistry, proverRegistry, appConsensusEngineFactory, inMemoryPeerInfoManager, frameProver, logger, coreId, parentProcess)
	globalTimeReel, err := provideGlobalTimeReel(appConsensusEngineFactory)
	if err != nil {
		return nil, err
	}
	dataWorkerNode, err := newDataWorkerNode(logger, pebbleDataProofStore, pebbleClockStore, pebbleTokenStore, fileKeyManager, pebbleDB, frameProver, dataWorkerIPCServer, globalTimeReel, coreId, parentProcess)
	if err != nil {
		return nil, err
	}
	return dataWorkerNode, nil
}

func NewDataWorkerNodeWithoutProxyPubsub(logger *zap.Logger, config2 *config.Config, coreId uint, rpcMultiaddr string, parentProcess int) (*DataWorkerNode, error) {
	dbConfig := config2.DB
	pebbleDB := store2.NewPebbleDB(logger, dbConfig, coreId)
	pebbleDataProofStore := store2.NewPebbleDataProofStore(pebbleDB, logger)
	pebbleClockStore := store2.NewPebbleClockStore(pebbleDB, logger)
	pebbleTokenStore := store2.NewPebbleTokenStore(pebbleDB, logger)
	bls48581KeyConstructor := provideBLSConstructor()
	decaf448KeyConstructor := provideDecafConstructor()
	fileKeyManager := keys.NewFileKeyManager(config2, bls48581KeyConstructor, decaf448KeyConstructor, logger)
	frameProver := vdf.NewCachedWesolowskiFrameProver(logger)
	pebbleKeyStore := store2.NewPebbleKeyStore(pebbleDB, logger)
	decaf448BulletproofProver := bulletproofs.NewBulletproofProver()
	cachedSignerRegistry, err := registration.NewCachedSignerRegistry(pebbleKeyStore, fileKeyManager, bls48581KeyConstructor, decaf448BulletproofProver, logger)
	if err != nil {
		return nil, err
	}
	mpCitHVerifiableEncryptor := newVerifiableEncryptor()
	kzgInclusionProver := bls48581.NewKZGInclusionProver(logger)
	pebbleHypergraphStore := store2.NewPebbleHypergraphStore(dbConfig, pebbleDB, logger, mpCitHVerifiableEncryptor, kzgInclusionProver)
	hypergraph, err := provideHypergraph(pebbleHypergraphStore)
	if err != nil {
		return nil, err
	}
	proverRegistry, err := provers.NewProverRegistry(logger, hypergraph)
	if err != nil {
		return nil, err
	}
	p2PConfig := config2.P2P
	engineConfig := config2.Engine
	blossomSub := p2p.NewBlossomSub(p2PConfig, engineConfig, logger, coreId)
	pebbleInboxStore := store2.NewPebbleInboxStore(pebbleDB, logger)
	pebbleShardsStore := store2.NewPebbleShardsStore(pebbleDB, logger)
	bedlamCompiler := compiler.NewBedlamCompiler()
	inMemoryPeerInfoManager := p2p.NewInMemoryPeerInfoManager(logger)
	dynamicFeeManager := fees.NewDynamicFeeManager(logger, kzgInclusionProver)
	blsAppFrameValidator := validator.NewBLSAppFrameValidator(proverRegistry, bls48581KeyConstructor, frameProver, logger)
	blsGlobalFrameValidator := validator.NewBLSGlobalFrameValidator(proverRegistry, bls48581KeyConstructor, frameProver, logger)
	uint64_2 := provideDifficultyAnchorFrameNumber(config2)
	int64_2 := provideDifficultyAnchorParentTime()
	uint32_2 := provideDifficultyAnchorDifficulty()
	asertDifficultyAdjuster := difficulty.NewAsertDifficultyAdjuster(uint64_2, int64_2, uint32_2)
	optimizedProofOfMeaningfulWorkRewardIssuance := reward.NewOptRewardIssuance()
	doubleRatchetEncryptedChannel := channel.NewDoubleRatchetEncryptedChannel()
	appConsensusEngineFactory := app.NewAppConsensusEngineFactory(logger, config2, blossomSub, hypergraph, fileKeyManager, pebbleKeyStore, pebbleClockStore, pebbleInboxStore, pebbleShardsStore, pebbleHypergraphStore, frameProver, kzgInclusionProver, decaf448BulletproofProver, mpCitHVerifiableEncryptor, decaf448KeyConstructor, bedlamCompiler, cachedSignerRegistry, proverRegistry, inMemoryPeerInfoManager, dynamicFeeManager, blsAppFrameValidator, blsGlobalFrameValidator, asertDifficultyAdjuster, optimizedProofOfMeaningfulWorkRewardIssuance, bls48581KeyConstructor, doubleRatchetEncryptedChannel)
	dataWorkerIPCServer := provideDataWorkerIPC(rpcMultiaddr, config2, cachedSignerRegistry, proverRegistry, appConsensusEngineFactory, inMemoryPeerInfoManager, frameProver, logger, coreId, parentProcess)
	globalTimeReel, err := provideGlobalTimeReel(appConsensusEngineFactory)
	if err != nil {
		return nil, err
	}
	dataWorkerNode, err := newDataWorkerNode(logger, pebbleDataProofStore, pebbleClockStore, pebbleTokenStore, fileKeyManager, pebbleDB, frameProver, dataWorkerIPCServer, globalTimeReel, coreId, parentProcess)
	if err != nil {
		return nil, err
	}
	return dataWorkerNode, nil
}

func NewMasterNode(logger *zap.Logger, config2 *config.Config, coreId uint) (*MasterNode, error) {
	dbConfig := config2.DB
	pebbleDB := store2.NewPebbleDB(logger, dbConfig, coreId)
	pebbleDataProofStore := store2.NewPebbleDataProofStore(pebbleDB, logger)
	pebbleClockStore := store2.NewPebbleClockStore(pebbleDB, logger)
	pebbleTokenStore := store2.NewPebbleTokenStore(pebbleDB, logger)
	bls48581KeyConstructor := provideBLSConstructor()
	decaf448KeyConstructor := provideDecafConstructor()
	fileKeyManager := keys.NewFileKeyManager(config2, bls48581KeyConstructor, decaf448KeyConstructor, logger)
	p2PConfig := config2.P2P
	engineConfig := config2.Engine
	blossomSub := p2p.NewBlossomSub(p2PConfig, engineConfig, logger, coreId)
	mpCitHVerifiableEncryptor := newVerifiableEncryptor()
	kzgInclusionProver := bls48581.NewKZGInclusionProver(logger)
	pebbleHypergraphStore := store2.NewPebbleHypergraphStore(dbConfig, pebbleDB, logger, mpCitHVerifiableEncryptor, kzgInclusionProver)
	hypergraph, err := provideHypergraph(pebbleHypergraphStore)
	if err != nil {
		return nil, err
	}
	pebbleKeyStore := store2.NewPebbleKeyStore(pebbleDB, logger)
	frameProver := vdf.NewCachedWesolowskiFrameProver(logger)
	decaf448BulletproofProver := bulletproofs.NewBulletproofProver()
	cachedSignerRegistry, err := registration.NewCachedSignerRegistry(pebbleKeyStore, fileKeyManager, bls48581KeyConstructor, decaf448BulletproofProver, logger)
	if err != nil {
		return nil, err
	}
	proverRegistry, err := provers.NewProverRegistry(logger, hypergraph)
	if err != nil {
		return nil, err
	}
	dynamicFeeManager := fees.NewDynamicFeeManager(logger, kzgInclusionProver)
	blsAppFrameValidator := validator.NewBLSAppFrameValidator(proverRegistry, bls48581KeyConstructor, frameProver, logger)
	blsGlobalFrameValidator := validator.NewBLSGlobalFrameValidator(proverRegistry, bls48581KeyConstructor, frameProver, logger)
	uint64_2 := provideDifficultyAnchorFrameNumber(config2)
	int64_2 := provideDifficultyAnchorParentTime()
	uint32_2 := provideDifficultyAnchorDifficulty()
	asertDifficultyAdjuster := difficulty.NewAsertDifficultyAdjuster(uint64_2, int64_2, uint32_2)
	optimizedProofOfMeaningfulWorkRewardIssuance := reward.NewOptRewardIssuance()
	pebbleInboxStore := store2.NewPebbleInboxStore(pebbleDB, logger)
	pebbleShardsStore := store2.NewPebbleShardsStore(pebbleDB, logger)
	pebbleWorkerStore := store2.NewPebbleWorkerStore(pebbleDB, logger)
	doubleRatchetEncryptedChannel := channel.NewDoubleRatchetEncryptedChannel()
	bedlamCompiler := compiler.NewBedlamCompiler()
	inMemoryPeerInfoManager := p2p.NewInMemoryPeerInfoManager(logger)
	consensusEngineFactory := global.NewConsensusEngineFactory(logger, config2, blossomSub, hypergraph, fileKeyManager, pebbleKeyStore, frameProver, kzgInclusionProver, cachedSignerRegistry, proverRegistry, dynamicFeeManager, blsAppFrameValidator, blsGlobalFrameValidator, asertDifficultyAdjuster, optimizedProofOfMeaningfulWorkRewardIssuance, pebbleClockStore, pebbleInboxStore, pebbleHypergraphStore, pebbleShardsStore, pebbleWorkerStore, doubleRatchetEncryptedChannel, decaf448BulletproofProver, mpCitHVerifiableEncryptor, decaf448KeyConstructor, bedlamCompiler, bls48581KeyConstructor, inMemoryPeerInfoManager)
	globalConsensusComponents, err := provideGlobalConsensusComponents(consensusEngineFactory, config2)
	if err != nil {
		return nil, err
	}
	globalConsensusEngine := provideGlobalConsensusEngine(globalConsensusComponents)
	globalTimeReel := provideGlobalTimeReelFromComponents(globalConsensusComponents)
	masterNode, err := newMasterNode(logger, pebbleDataProofStore, pebbleClockStore, pebbleTokenStore, fileKeyManager, blossomSub, globalConsensusEngine, globalTimeReel, pebbleDB, coreId)
	if err != nil {
		return nil, err
	}
	return masterNode, nil
}

// wire.go:

func provideBLSConstructor() *bls48581.Bls48581KeyConstructor {
	return &bls48581.Bls48581KeyConstructor{}
}

func provideDecafConstructor() *bulletproofs.Decaf448KeyConstructor {
	return &bulletproofs.Decaf448KeyConstructor{}
}

var keyManagerSet = wire.NewSet(wire.FieldsOf(new(*config.Config), "Key"), provideBLSConstructor, wire.Bind(new(crypto.BlsConstructor), new(*bls48581.Bls48581KeyConstructor)), provideDecafConstructor, wire.Bind(
	new(crypto.DecafConstructor),
	new(*bulletproofs.Decaf448KeyConstructor),
), keys.NewFileKeyManager, wire.Bind(new(keys2.KeyManager), new(*keys.FileKeyManager)),
)

func newVerifiableEncryptor() *verenc.MPCitHVerifiableEncryptor {
	return verenc.NewMPCitHVerifiableEncryptor(1)
}

var compilerSet = wire.NewSet(compiler.NewBedlamCompiler, wire.Bind(new(compiler2.CircuitCompiler), new(*compiler.BedlamCompiler)))

var verencSet = wire.NewSet(
	newVerifiableEncryptor, wire.Bind(
		new(crypto.VerifiableEncryptor),
		new(*verenc.MPCitHVerifiableEncryptor),
	),
)

var storeSet = wire.NewSet(wire.FieldsOf(new(*config.Config), "DB"), store2.NewPebbleDB, wire.Bind(new(store.KVDB), new(*store2.PebbleDB)), store2.NewPebbleClockStore, store2.NewPebbleTokenStore, store2.NewPebbleDataProofStore, store2.NewPebbleHypergraphStore, store2.NewPebbleInboxStore, store2.NewPebbleKeyStore, store2.NewPeerstoreDatastore, store2.NewPebbleShardsStore, store2.NewPebbleWorkerStore, wire.Bind(new(store.ClockStore), new(*store2.PebbleClockStore)), wire.Bind(new(store.TokenStore), new(*store2.PebbleTokenStore)), wire.Bind(new(store.DataProofStore), new(*store2.PebbleDataProofStore)), wire.Bind(new(store.HypergraphStore), new(*store2.PebbleHypergraphStore)), wire.Bind(new(store.InboxStore), new(*store2.PebbleInboxStore)), wire.Bind(new(store.KeyStore), new(*store2.PebbleKeyStore)), wire.Bind(new(tries.TreeBackingStore), new(*store2.PebbleHypergraphStore)), wire.Bind(new(store.ShardsStore), new(*store2.PebbleShardsStore)), wire.Bind(new(store.WorkerStore), new(*store2.PebbleWorkerStore)))

var pubSubSet = wire.NewSet(wire.FieldsOf(new(*config.Config), "P2P"), wire.FieldsOf(new(*config.Config), "Engine"), p2p.NewInMemoryPeerInfoManager, p2p.NewBlossomSub, channel.NewDoubleRatchetEncryptedChannel, wire.Bind(new(p2p2.PubSub), new(*p2p.BlossomSub)), wire.Bind(new(p2p.PeerInfoManager), new(*p2p.InMemoryPeerInfoManager)), wire.Bind(
	new(channel2.EncryptedChannel),
	new(*channel.DoubleRatchetEncryptedChannel),
),
)

var proxyPubSubSet = wire.NewSet(wire.FieldsOf(new(*config.Config), "P2P"), wire.FieldsOf(new(*config.Config), "Engine"), p2p.NewInMemoryPeerInfoManager, rpc.NewProxyBlossomSub, channel.NewDoubleRatchetEncryptedChannel, wire.Bind(new(p2p2.PubSub), new(*rpc.ProxyBlossomSub)), wire.Bind(new(p2p.PeerInfoManager), new(*p2p.InMemoryPeerInfoManager)), wire.Bind(
	new(channel2.EncryptedChannel),
	new(*channel.DoubleRatchetEncryptedChannel),
),
)

var engineSet = wire.NewSet(vdf.NewCachedWesolowskiFrameProver, bls48581.NewKZGInclusionProver, wire.Bind(new(crypto.InclusionProver), new(*bls48581.KZGInclusionProver)), bulletproofs.NewBulletproofProver, wire.Bind(
	new(crypto.BulletproofProver),
	new(*bulletproofs.Decaf448BulletproofProver),
),
)

func provideHypergraph(store3 *store2.PebbleHypergraphStore,
) (hypergraph.Hypergraph, error) {
	return store3.LoadHypergraph(&tests.Nopthenticator{})
}

var hypergraphSet = wire.NewSet(
	provideHypergraph,
)

var validatorSet = wire.NewSet(registration.NewCachedSignerRegistry, wire.Bind(
	new(consensus.SignerRegistry),
	new(*registration.CachedSignerRegistry),
), provers.NewProverRegistry, fees.NewDynamicFeeManager, validator.NewBLSGlobalFrameValidator, wire.Bind(
	new(consensus.GlobalFrameValidator),
	new(*validator.BLSGlobalFrameValidator),
), validator.NewBLSAppFrameValidator, wire.Bind(
	new(consensus.AppFrameValidator),
	new(*validator.BLSAppFrameValidator),
), provideDifficultyAnchorFrameNumber,
	provideDifficultyAnchorParentTime,
	provideDifficultyAnchorDifficulty, difficulty.NewAsertDifficultyAdjuster, wire.Bind(
		new(consensus.DifficultyAdjuster),
		new(*difficulty.AsertDifficultyAdjuster),
	), reward.NewOptRewardIssuance, wire.Bind(
		new(consensus.RewardIssuance),
		new(*reward.OptimizedProofOfMeaningfulWorkRewardIssuance),
	),
)

var globalConsensusSet = wire.NewSet(global.NewConsensusEngineFactory)

var appConsensusSet = wire.NewSet(app.NewAppConsensusEngineFactory)

func NewDataWorkerNode(
	logger *zap.Logger, config2 *config.Config,
	coreId uint,
	rpcMultiaddr string,
	parentProcess int,
) (*DataWorkerNode, error) {
	if config2.Engine.EnableMasterProxy {
		return NewDataWorkerNodeWithProxyPubsub(
			logger, config2, coreId,
			rpcMultiaddr,
			parentProcess,
		)
	} else {
		return NewDataWorkerNodeWithoutProxyPubsub(
			logger, config2, coreId,
			rpcMultiaddr,
			parentProcess,
		)
	}
}

func provideDataWorkerIPC(
	rpcMultiaddr string, config2 *config.Config,
	signerRegistry consensus.SignerRegistry,
	proverRegistry consensus.ProverRegistry,
	appConsensusEngineFactory *app.AppConsensusEngineFactory,
	peerInfoManager p2p.PeerInfoManager,
	frameProver crypto.FrameProver,
	logger *zap.Logger,
	coreId uint,
	parentProcess int,
) *datarpc.DataWorkerIPCServer {
	svr, err := datarpc.NewDataWorkerIPCServer(
		rpcMultiaddr, config2, signerRegistry,
		proverRegistry,
		peerInfoManager,
		frameProver,
		appConsensusEngineFactory,
		logger,
		uint32(coreId),
		parentProcess,
	)
	if err != nil {
		panic(err)
	}
	return svr
}

// GlobalConsensusComponents holds both the engine and time reel
type GlobalConsensusComponents struct {
	Engine   *global.GlobalConsensusEngine
	TimeReel *time.GlobalTimeReel
}

func provideGlobalConsensusComponents(
	factory *global.ConsensusEngineFactory, config2 *config.Config,
) (*GlobalConsensusComponents, error) {
	engine, timeReel, err := factory.CreateGlobalConsensusEngine(10000)
	if err != nil {
		return nil, err
	}
	return &GlobalConsensusComponents{
		Engine:   engine,
		TimeReel: timeReel,
	}, nil
}

func provideGlobalConsensusEngine(
	components *GlobalConsensusComponents,
) *global.GlobalConsensusEngine {
	return components.Engine
}

func provideGlobalTimeReelFromComponents(
	components *GlobalConsensusComponents,
) *time.GlobalTimeReel {
	return components.TimeReel
}

// Provider functions for difficulty adjuster parameters
func provideDifficultyAnchorFrameNumber(config2 *config.Config) uint64 {
	if config2.P2P.Network == 0 {
		return 244200
	} else {
		return 0
	}
}

func provideDifficultyAnchorParentTime() int64 {
	return 1759226400000
}

func provideDifficultyAnchorDifficulty() uint32 {
	return 160000
}

func provideGlobalTimeReel(
	factory *app.AppConsensusEngineFactory,
) (*time.GlobalTimeReel, error) {
	return factory.CreateGlobalTimeReel()
}
